"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = void 0;
const app = require(".");
class Channel {
    constructor(pid) {
        this.socket = new WebSocket(`ws://${location.host}/ws/direct/${pid}`);
        this.socket.binaryType = 'arraybuffer';
        this.socket.addEventListener('message', x => this.receive(x));
        this.tracker = new app.Tracker();
    }
    create(adapter) {
        this.tracker.create(adapter.source);
    }
    delete(adapter) {
        this.tracker.delete(adapter.source);
    }
    async runAsync(renderFrame) {
        while (true) {
            switch (this.socket.readyState) {
                case this.socket.CONNECTING:
                    await new Promise(requestAnimationFrame);
                    break;
                case this.socket.OPEN:
                    renderFrame();
                    this.update();
                    await new Promise(requestAnimationFrame);
                    break;
                default:
                    throw new Error('Invalid channel state!');
            }
        }
    }
    receive(ev) {
        if (ev.data instanceof ArrayBuffer) {
            const reader = new app.BinaryReader(new DataView(ev.data));
            while (reader.hasBytes()) {
                switch (reader.readUInt8()) {
                    case app.PacketType.Update:
                        this.tracker.receive(app.UpdateArray.create(reader));
                        break;
                }
            }
        }
    }
    update() {
        const writer = new app.BinaryWriter();
        this.tracker.update(writer);
        if (!this.nextActiveTime || this.nextActiveTime < Date.now()) {
            writer.writeUInt8(app.PacketType.Activity);
            this.nextActiveTime = Date.now() + 10000;
            this.socket.send(writer.toBuffer());
        }
        else if (writer.hasBytes()) {
            this.socket.send(writer.toBuffer());
        }
    }
}
exports.Channel = Channel;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hhbm5lbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvYXBpL0NoYW5uZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBRXpCLE1BQWEsT0FBTztJQUtsQixZQUFZLEdBQVc7UUFDckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQyxRQUFRLFFBQVEsQ0FBQyxJQUFJLGNBQWMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUN0RSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxhQUFhLENBQUM7UUFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDOUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNuQyxDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQWdDO1FBQ3JDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQWdDO1FBQ3JDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxXQUF1QjtRQUNwQyxPQUFPLElBQUksRUFBRTtZQUNYLFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7Z0JBQzlCLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVO29CQUN6QixNQUFNLElBQUksT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7b0JBQ3pDLE1BQU07Z0JBQ1IsS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUk7b0JBQ25CLFdBQVcsRUFBRSxDQUFDO29CQUNkLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDZCxNQUFNLElBQUksT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUM7b0JBQ3pDLE1BQU07Z0JBQ1I7b0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO2FBQzdDO1NBQ0Y7SUFDSCxDQUFDO0lBRU8sT0FBTyxDQUFDLEVBQWdCO1FBQzlCLElBQUksRUFBRSxDQUFDLElBQUksWUFBWSxXQUFXLEVBQUU7WUFDbEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxDQUFDLElBQUksUUFBUSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzNELE9BQU8sTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFO2dCQUN4QixRQUFRLE1BQU0sQ0FBQyxTQUFTLEVBQW9CLEVBQUU7b0JBQzVDLEtBQUssR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNO3dCQUN4QixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO3dCQUNyRCxNQUFNO2lCQUNUO2FBQ0Y7U0FDRjtJQUNILENBQUM7SUFFTyxNQUFNO1FBQ1osTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUU7WUFDNUQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQztZQUN6QyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztTQUNyQzthQUFNLElBQUksTUFBTSxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQzVCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQ3JDO0lBQ0gsQ0FBQztDQUNGO0FBN0RELDBCQTZEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFwcCBmcm9tICcuJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDaGFubmVsIHtcclxuICBwcml2YXRlIHJlYWRvbmx5IHRyYWNrZXI6IGFwcC5UcmFja2VyO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgc29ja2V0OiBXZWJTb2NrZXQ7XHJcbiAgcHJpdmF0ZSBuZXh0QWN0aXZlVGltZT86IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IocGlkOiBudW1iZXIpIHtcclxuICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldChgd3M6Ly8ke2xvY2F0aW9uLmhvc3R9L3dzL2RpcmVjdC8ke3BpZH1gKTtcclxuICAgIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHggPT4gdGhpcy5yZWNlaXZlKHgpKTtcclxuICAgIHRoaXMudHJhY2tlciA9IG5ldyBhcHAuVHJhY2tlcigpO1xyXG4gIH1cclxuXHJcbiAgY3JlYXRlKGFkYXB0ZXI6IGFwcC5BZGFwdGVyPGFwcC5FbnRpdHk+KSB7XHJcbiAgICB0aGlzLnRyYWNrZXIuY3JlYXRlKGFkYXB0ZXIuc291cmNlKTtcclxuICB9XHJcblxyXG4gIGRlbGV0ZShhZGFwdGVyOiBhcHAuQWRhcHRlcjxhcHAuRW50aXR5Pikge1xyXG4gICAgdGhpcy50cmFja2VyLmRlbGV0ZShhZGFwdGVyLnNvdXJjZSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBydW5Bc3luYyhyZW5kZXJGcmFtZTogKCkgPT4gdm9pZCkge1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgc3dpdGNoICh0aGlzLnNvY2tldC5yZWFkeVN0YXRlKSB7XHJcbiAgICAgICAgY2FzZSB0aGlzLnNvY2tldC5DT05ORUNUSU5HOlxyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgdGhpcy5zb2NrZXQuT1BFTjpcclxuICAgICAgICAgIHJlbmRlckZyYW1lKCk7XHJcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhbm5lbCBzdGF0ZSEnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSByZWNlaXZlKGV2OiBNZXNzYWdlRXZlbnQpIHtcclxuICAgIGlmIChldi5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcclxuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IGFwcC5CaW5hcnlSZWFkZXIobmV3IERhdGFWaWV3KGV2LmRhdGEpKTtcclxuICAgICAgd2hpbGUgKHJlYWRlci5oYXNCeXRlcygpKSB7XHJcbiAgICAgICAgc3dpdGNoIChyZWFkZXIucmVhZFVJbnQ4KCkgYXMgYXBwLlBhY2tldFR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgYXBwLlBhY2tldFR5cGUuVXBkYXRlOlxyXG4gICAgICAgICAgICB0aGlzLnRyYWNrZXIucmVjZWl2ZShhcHAuVXBkYXRlQXJyYXkuY3JlYXRlKHJlYWRlcikpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgdXBkYXRlKCkge1xyXG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IGFwcC5CaW5hcnlXcml0ZXIoKTtcclxuICAgIHRoaXMudHJhY2tlci51cGRhdGUod3JpdGVyKTtcclxuICAgIGlmICghdGhpcy5uZXh0QWN0aXZlVGltZSB8fCB0aGlzLm5leHRBY3RpdmVUaW1lIDwgRGF0ZS5ub3coKSkge1xyXG4gICAgICB3cml0ZXIud3JpdGVVSW50OChhcHAuUGFja2V0VHlwZS5BY3Rpdml0eSk7XHJcbiAgICAgIHRoaXMubmV4dEFjdGl2ZVRpbWUgPSBEYXRlLm5vdygpICsgMTAwMDA7XHJcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQod3JpdGVyLnRvQnVmZmVyKCkpO1xyXG4gICAgfSBlbHNlIGlmICh3cml0ZXIuaGFzQnl0ZXMoKSkge1xyXG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHdyaXRlci50b0J1ZmZlcigpKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19